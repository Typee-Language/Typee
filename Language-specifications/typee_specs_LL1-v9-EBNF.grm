/*****
Copyright (c) 2018 Philippe Schmouker, Typee project, http://www.typee.ovh

Permission is hereby granted,  free of charge,  to any person obtaining a copy
of this software and associated documentation files (the "Software"),  to deal
in the Software without restriction, including  without  limitation the rights
to use,  copy,  modify,  merge,  publish,  distribute, sublicense, and/or sell
copies of the Software,  and  to  permit  persons  to  whom  the  Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY  KIND,  EXPRESS  OR
IMPLIED,  INCLUDING  BUT  NOT  LIMITED  TO  THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT  SHALL  THE
AUTHORS  OR  COPYRIGHT  HOLDERS  BE  LIABLE  FOR  ANY CLAIM,  DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  TORT OR OTHERWISE, ARISING FROM,
OUT  OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*****/


/*****   CODE FILE   ************************************************/

<code file> ::=  [<statements list>] <ENDOFFILE>




/*****   ATOMS   ****************************************************/

<atom element>          ::= <atom>                           |
                            <dotted name> [<atom element'>]  |
                            [ <const qualifier> ] <scalar type> 
                                <scalar type casting>
                            
<atom element'>         ::= <is instance of>  |
                            <scalar type casting>  |
                            ( <function call> | <subscription or slicing> )*

<atom>                  ::= [<decr> | <incr>]  <dotted name>  [<decr> | <incr>]  |
                            <enclosure>  |  <reference>  |  
                            <scalar>  |  <string>  |  <boolean>

<boolean>               ::= <TRUE>  |  <FALSE>

<bracket form>          ::= '[' <expression> <list or map form> ']' 

<decr>                  ::= '--' 

<enclosure>             ::= <bracket form>  |  <parenthesis form>

<incr>                  ::= '++' 

<is instance of>        ::= '->' <dotted name>

<list or comprehension> ::= [ ( ',' <expression> )*  |  <for comprehension> ]
                 
<list or map form>      ::= <list form>  |  <map form>

<list form>             ::= '[' <expression> <list or comprehension> ']' 

<parenthesis form>      ::= '(' <expr list> ')' 

<reference>             ::= '@' <dotted name>

<scalar type casting>   ::= '(' <expression> ')' 

<slice end>             ::= ']'  |  ')' 

<slice form>            ::= ':' [<expression>]  [ ':' [<expression>] ]

<subscription or slicing>   ::= <subscription or slicing'>
                                    (<subscription or slicing'>)*
<subscription or slicing'>  ::= '[' <expression>
                                    ( ']'                     |
                                      <if comprehension> ']'  |
                                      <slice form> <slice end> )



/*****   CLASSES   *******************************************/

<class declaration>         ::= <forward> <class decl def> ';'

<class definition>          ::= <class decl def> <class statements block>

<class decl def>            ::= 'class' <identifier> [<template def>] [<inheritance> ]

<class statements block>    ::= '{' [<class statements list>] '}'

<class statements list>     ::= ( <access protection statement>                |
                                  [<access qualifier>] <decl or def statement> |
                                  <empty statement>                              )*

<inheritance>               ::= ':' <inheritance item> (',' <inheritence item>)*

<inheritance item>          ::= [<access qualifier>] <dotted name> [<template args>]



/*****   COMPREHENSION   ********************************************/

<for comprehension>     ::= 'for' '(' <targets list> 
                                'in' <or test> <iter comprehension> ')' 

<if comprehension>      ::= 'if' '(' (<or test> | <unnamed func>) ')' 
                                <iter comprehension>

<iter comprehension>    ::= [ <for comprehension>  |  <if comprehension> ]




/*****   CONDITIONS and COMPARISONS   *******************************/

<condition>         ::= <or test>  [ 'if' <or test> 'else' <expression> ]

<and test>          ::= <not test>  [ 'and' <not test> ]

<comparison>        ::= <bitor expr>  ( (<comp operator> [<template args>] |
                                            <comp operator'> 
                                            [<spaced template args>]) 
                                            <bitor expr> )*

<comp operator>     ::= '<='  |  '=='  |  '!='  |  '>='  |
                        'in'  |  'is' [ 'not' ]  |  'not' 'in' 

<comp operator'>    ::=  '<'  |  '>' 
 
<not test>          ::= 'not' <not test>  |  <comparison>

<or test>           ::= <and test>  [ 'or' <and test> ]



/*****   EXPRESSIONS   **********************************************/

<expression>            ::= <condition>  |  <unnamed func>

<parenthesised expr>    ::= '(' <expression> ')' 

<arithmetic expr>       ::= <term>  ( <op_add> [<template args>] <term> )*

<expr list>             ::= <expression>  ( ',' <expression> )*

<factor>                ::= <atom element>
                                ( <op_power> [<template args>] <unary expr> )*

<identifier>            ::= ( <alpha char> | '_' )  ( <alpha num char> | '_' )*

<indexed expr list>     ::= 'indexed' '(' <expr list> ')'  |
                            <expr list>

<map form>              ::= ':' <expression> [<map list or comprehension>]

<map item>              ::= <expression> ':' <expression>

<map list>              ::= ( ',' <map item> )*
             
<map list or comprehension> ::= <map list>  |  <for comprehension>

<bitand expr>           ::= <shift expr> ( '&' [<template args>] <shift expr> )*

<bitor expr>            ::= <bitxor expr> ( '|' [<template args>] <bitxor expr> )*

<bitxor expr>           ::= <bitand expr> [ '^' [<template args>] <bitand expr> ]

<shift expr>            ::= <arithmetic expr>
                                ((( '<<' | '<<<' ) [<spaced template args>]  |
                                  ( '>>' | '>>>' ) [<template args>]) 
                                    <arithmetic expr>)*

<term>                  ::= <factor> ( ( ((<op_mul> | <op_user>) 
                                              [<template args>]) |
                                         '><' [<spaced template args>] )
                                        <factor> )*
             
<unary expr>            ::= [ '+' | '-' | '~' | '#' ]  <factor>


/*****   FUNCTIONS   ************************************************/

<function declaration>      ::= [<template def>]  <function args declaration>

<function definition>       ::= [<template def>]  <function args declaration>
                                    <statements block>

<function args declaration> ::= '(' [<typed args list>] ')' 

<function call>             ::= [<template args>] '(' <function call args> ')' 

<function call args>        ::= [ <expression> (<function call>)*
                                    [ ',' ( <expression> (<function call>)*  |
                                            <ellipsis> <identifier> )  |
                                      <for comprehension>] ]

<typed args list>           ::= <TYPE> <var or func identifier> ( ',' <TYPE> <var or func identifier> )*

<unnamed>                   ::= 'unnamed'  |  'lambda' 

<unnamed func>              ::= <unnamed> [<TYPE>] <function args declaration>
                                    <statements block>

<var or func identifier>    ::= <identifier> [<enclosed types list>]


/*****   MISC   *****************************************************/

<alpha char>                    ::= 'A' ... 'Z'  |  'a' ... 'z' 

<alpha num char>                ::= <alpha char>   |  <num char>

<any embedded code char>        ::= u0x0000...u0xFFFF - ( '}' )

<any escaped char>              ::= '\\' u0x0000...u0xFFFF -
                                        ( '\n', '\r', '\f', u0x00 )

<any non newline char>          ::= u0x0000...u0xFFFF - ( '\n', '\r', '\f' )

<any non star char>             ::= u0x0000...u0xFFFF - ( '*' )

<any string quote char>         ::= u0x0000...u0xFFFF - 
                                        ( "'", "\\", "\n", "\r", "\f", u0x00 )
<any string doublequote char>   ::= u0x0000...u0xFFFF -
                                        ( '"', '\\', '\n', '\r', '\f', u0x00 )

<binary char>                   ::= '0'  |  '1' 

<ellipsis>                      ::= '...' 

<ENDOFFILE>                     ::= u0x00

<escaped char>                  ::= '\\' ( <alpha char> | 
                                           ( '0' <octal or hexa char> ) )

<line end>                      ::= <NEWLINE>  |  <ENDOFFILE>

<octal or hexa char>            ::= <octal char> <octal char> <octal char> | 
                                    ( 'x' | 'X' ) <hexa char> <hexa char> 
                                        [ <hexa char> <hexa char> ]

<FALSE>                         ::= 'False'  |  'false' 

<hexa char>                     ::= <num char>  |  'A' ... 'F'  |  'a' ... 'f' 

<ME>                            ::= 'me' 

<NEWLINE>                       ::= '\n'  |  '\r'  |  '\f' 

<NONE>                          ::= 'None'  |  'none' 

<num char>                      ::= '0'...'9' 

<parenth close>                 ::= ')' 
<parenth open>                  ::= '(' 

<octal char>                    ::= '0' ... '7' 

<single char>                   ::= "'" (<any escaped char> |
                                         <any string quote char>) "'"  |
                                    '"' (<any escaped char> |
                                         <any string doublequote char>) '"' 

<TRUE>                          ::= 'True'  |  'true' 




/*****   OPERATORS   ************************************************/

<operator>              ::= <operator">  |  <op_incr_decr>
<operator'>             ::= '<'  |  '>'  |  '<<'  |  '>>'  |  '<<<'  |  '>>>' 
<operator">             ::= '<='  |  '=='  |  '!='  |  '>='  |
                            '&'   |  '|'   |  '^'   |  '#'   |
                            'in'  |
                            <op_add>   |  <op_mul>  |  <op_power>  |
                            <op_user>  |
                            <assign op>

<assign op>             ::= '='  |  <augmented assign op>

<call operator>         ::= '(' ')' 

<comp operator>         ::= '<='  |  '=='  |  '!='  |  '>='  |
                            'in'  |  'is' [ 'not' ]  |  'not' 'in' 

<comp operator'>        ::=  '<'  |  '>' 

<op_add>                ::= '+'   |  '-' 
<op_incr_decr>          ::= '++'  |  '--' 
<op_mul>                ::= '*'   |  '/'  |  '%' 
<op_power>              ::= '**'  |  '^^' 
<op_user>               ::= '@'   |  '><'  |  '!!'  |  '::'  |  '??'

<operator declaration>  ::= 'operator' 
                                ( (<operator"> [<template def>] <function args declaration>)                  |
                                  (<operator'> [<spaced template def>] <function args declaration>)           |
                                  (<incr decr op> [<template def>] <pre or post> <function args declaration>) |
                                  (<call operator> <template def>) )

<operator definition>   ::= <operator declaration> <statements block>




/*****   SCALARS   **************************************************/

<scalar>            ::= '0' <octal hexa binary>  |
                        '1' ... '9' [<decimal part>]
                            [<fraction part> [<exponent part>]]

<binary number>     ::= <binary char> ([ '_' ] <binary char>)*
                     
<decimal part>      ::= <num_char> (['_'] <num_char>)*

<exponent part>     ::= ( 'e' | 'E' )  [ '+' | '-' ] <decimal part>

<fraction part>     ::= '.' <decimal part>

<hexadecimal number>::= <hexa char> ( [ '_' ] <hexa char> )*

<integer number>    ::= '1' ... '9' [<decimal part>]  |  '0' <octal hexa binary>
             
<octal hexa binary> ::= <octal number>  |
                            ( 'b' | 'B' ) <binary number>  |
                            ( 'x' | 'X' ) <hexadecimal number>

<octal number>      ::= <octal char> ( [ '_' ] <octal char> )*




/*****   STATEMENTS   ****************************************/

<statements list>           ::= <statement>  ( <statement> )*

<statement>                 ::= <empty statement>   |  <compound statement>  |
                                <simple statement>  |  <statements block>

<compound statement>        ::= <assign decl def func-call statement>  |
                                <embed statement>                      |
                                <for statement>                        |
                                <forever statement>                    |
                                <if statement>                         |
                                <repeat statement>                     |
                                <switch statement>                     |
                                <try statement>                        |
                                <while statement>                      |
                                <with statement>

<empty statement>           ::= <comment>  |  <NEWLINE>

<simple statement>          ::= ( <assert statement> | <del statement>  |
                                  <ensure statement> | <flow statement> |
                                  <import statement> | <nop statement>  |
                                  <access protection statement>         |
                                  <require statement> )
                                <simple statement end>

<simple statement end>      ::= ';' 

<statements block>          ::= '{' [<statements list>] '}'               |  
                                <compound statement>                      |
                                [<nop statement>] <simple statement end>  |
                                <simple statement>


<abstract or final qualif>  ::= 'abstract' | 'final' 

<access protection statement>  ::= ':' <access qualifier> ':' 

<access qualifier>          ::= 'hidden'  |  'local'  |  'private'  |
                                'protected'  |  'public' 

<array content>         ::= '[' (<items list> | <array content>) ']'

<array declaration>     ::= <array type> <identifier> [ '=' <array content> ]

<assert statement>          ::= 'assert' <expression> ( ',' <expression>) *

<assign decl def func-call statement>   ::= [<access qualifier>]
                                                <decl or def statement>  |
                                            <dotted name>
                                                <assign or func-call statement> 
                                                <simple statement end>

<assign or func-call statement> ::= <targets list> <assignment statement>  |
                                    <function call>

<assignment statement>      ::= <assign op> <expr list>

<augmented assign op>       ::= '+='   |  '-='   |  '*='  |  '/='   |  '%='  |
                                '&='   |  '|='   |  '^='  |
                                '<<='  |  '<<<=' |  '>>=' |  '>>>=' |
                                '**='  |  '^^='  |  '@='  |
                                '><='  |  '!!='  |  '::=' |  '??=' 

<case>                      ::= 'case' <expr list> <statements block>

<comment>                   ::= '//' ( (<any non newline char>)* |
                                            <line end>          )  |
                                '/*' <multi lines comment>

<container declaration>     ::= <array declaration> |
                                <file declaration>  |
                                <list declaration>  |
                                <map declaration>   |
                                <set declaration>

<decl constructor or decl end>  ::= ( '.' <identifier> )*
                                        <decl or def statement'''>  |
                                    <function definition'>

<decl or def statement>     ::= [<static qualifier>] <decl or def statement'> |  
                                <class definition>                            |
                                <forward decl>

<decl or def statement'>    ::= <abstract or final qualif> 
                                    <method or operator definition>           |
                                <volatile qualifier> <type> <identifier> 
                                    [<memory address>] <simple statement end> |
                                <enum decl or def>                            |
                                <type alias> <simple statement end>           |
                                <decl or def statement''>

<decl or def statement''>   ::= [<const qualifier>] <decl or def statement'''> |
                                <identifier> <decl constructor or decl end>

<decl or def statement'''>  ::= <type> <decl or def statement''''>  |
                                <container declaration>

<decl or def statement''''> ::= <identifier> <decl or def statement'''''>  |
                                <operator definition>

<decl or def statement''''> ::= <function definition>           | 
                                <var declaration or assignment>
                                    <simple statement end>

<del statement>             ::= ( 'del' | 'delete' ) <identifiers list>
                      
<dotted as name>            ::= <dotted name> [ 'as' <identifier> ]

<dotted as names>           ::= ( '.' )* <dotted as name> 
                                    ( ',' ( '.' )* <dotted as name> )*

<dotted name>               ::= <identifier> ( '.' <identifier> )*

<embed statement>           ::= 'embed' <language> (<dotted name>
                                    <simple statement end>          |
                                <embedded language code>)

<embedded language code>    ::= '{{' <embedded language code'>
<embeded language code'>    ::= <any embedded code char>
                                    <embeded language code'>  |
                                '}' <embedded language code">
<embedded language code">   ::= <any embedded code char>
                                    <embeded language code'>  |
                                '}' 

<ensure statement>          ::= 'ensure' <expression> ( ',' <expression> )*

<enum decl or def>          ::= <enum type> <identifier>
                                    (<enum declaration> | <enum definition>)

<enum declaration>          ::= <identifier> ';' 

<enum definition>           ::= '{' <enum item> (',' <enum item>)* '}' 

<enum item>                 ::= <identifier> [ '=' <expression> ]
                             
<flow statement>            ::= 'break'  |  'continue'  |
                                <raise statement>  |  <return statement>

<for statement>             ::= 'for' '(' <typed targets list>
                                    'in' <indexed expr list> ')' <statements block>
                                    [ 'otherwise' <statements block> ]
                                    
<forever statement>         ::= 'forever' '(' ')' <statements block>

<forward>                   ::= 'forward'  |  'fwd' 

<forward decl>              ::= <forward> ( ([<static qualifier>] 
                                                <forward decl'>) | 
                                             <fwd class decl> ) <simple statement end>
<forward decl'>             ::= <volatile qualifier> <type> <identifier> |
                                <fwd type decl>                          |
                                <identifier> <fwd decl constructor>      |
                                <TYPE'> ( <operator declaration>  |
                                          (<identifier>
                                               (<fwd var decl> |
                                                    <function declaration>)) )

<fwd class decl>            ::= 'class' <identifier>
                                    <template def> [<inheritance>]

<fwd decl constructor>      ::= ( '.' <identifier> )*
                                    (<operator declaration> |
                                     <identifier>
                                         (<fwd var decl> | 
                                          <function declaration>)) |
                                <function args declaration>

<fwd type decl>             ::= 'type' <identifier>

<fwd var decl>              ::= ( ',' <identifier> )*

<identifiers list>          ::= <dotted name>  ( ',' <dotted name> )*

<if statement>              ::= 'if' <parenthesised expr>
                                    <statements block> [<elif statement'>]
<elif statement'>           ::= ( 'elseif' <parenthesised expr>
                                      <statements block> )*    |
                                ( 'elif' <parenthesised expr>
                                      <statements block> )*    |
                                ( 'elsif' <parenthesised expr>
                                      <statements block> )*    |
                                'else' <statements block>

<import as name>            ::= <identifier> [ 'as' <identifier> ]

<import as names>           ::= <import as name> ( ',' <import as name> )*

<import from>               ::= 'from' ( '.' )* <dotted name> 'import'  
                                    ( 'all'                            |
                                      <parenth open> <import as names>
                                          <parenth close>              |
                                      <import as names> )

<import name>               ::= 'import' <dotted as names>

<import statement>          ::= <import name>  |  <import from>

<items list>                ::= [ <expression> ( ',' <expression> )* ]

<language>                  ::= 'cpp'  |  'java'  |  'python'  |  'py' 

<list content>              ::= '[' (<items list> | <list content>) ']'

<list declaration>          ::= <list type> <identifier> [ '=' <list content> ]

<map content>               ::= '[' [<expression> <map form>] ']' 

<map declaration>           ::= <map type> <identifier> [ '=' <map content> ]

<memory address>            ::= '@' <integer number>

<method or operator definition> ::= [<TYPE>] (<operator definition> |
                                    <identifier> <function definition>)                                 

<multi lines comment>       ::= (<any non star char> | <NEWLINE>)*  |
                                '*' ( '/' | <multi lines comment> )

<nop statement>             ::= 'nop'  |  'pass' 

<raise statement>           ::= 'raise' <expression> [ 'from' <expression> ]

<repeat statement>          ::= 'repeat' <statements block> 'until' 
                                    <parenthesised expr> <simple statement end>

<require statement>         ::= 'require' <expression> [ ',' <expression> ]

<return statement>          ::= ( 'ret' | 'return' ) <expr list>

<set content>               ::= '[' <set item> ( ',' <set item> )* ']'

<set declaration>           ::= <set type> <identifier> [ '=' <set content> ]

<set item>                  ::= <expression> [<for comprehension>]

<switch block>              ::= (<case> [<switch block>])*

<switch statement>          ::= 'switch' <parenthesised expr>
                                    '{' [<switch block>] '}' 
                                    [ 'otherwise' <statements block> ]

<target>                    ::= <dotted name> (<subscription or slicing>)*

<targets list>              ::= <target> ( ',' <target> )*

<try else>                  ::= 'otherwise' 

<try except>                ::= 'except' '(' [( <try except expr> | 'all' )] ')' 
<try except expr>           ::= <expression> [ 'as' <identifier> ]
                                    ( ',' <expression> [ 'as' <identifier> ] )*

<try finally>               ::= 'finally' 

<try statement>             ::= 'try' <statements block> <try except>
                                    <statements block>
                                    (<try except> <statements block>)*
                                    [<try else> <statements block>]
                                    [<try finally> <statements block>]

<type alias>                ::= 'type' <TYPE> 'as' <identifier>
                                    ( ',' <TYPE> 'as' <identifier>) *

<typed target>              ::= <type'> <target>  |
                                <dotted name>
                                    [<dotted name> | <templated type spec>]
                                    (<subscription or slicing>)*

<typed targets list>        ::= <typed target> ( ',' <typed target> )*

<var declarations or assignments> ::= [ '=' <expression> ]
                                          [ ( ',' <identifier>
                                                [ '=' <expression> ] )* ]

<while statement>           ::= 'while' <parenthesised expr> <statements block> 
                                    [ 'otherwise' <statements block> ]

<with item>                 ::= <expression> [ 'as' <target> ]

<with items list>           ::= <with item> ( ',' <with item> )*

<with statement>            ::= 'with' <with items list> <statements block>




/*****   STRINGS   **************************************************/

<string>        ::= <single string> (<single string>)*
                        ( '.' <identifier> <function call> )*


<single string> ::= "'" (<any escaped char> | <any string quote char>)* "'"  |
                    '"' (<any escaped char> | <any string doublequote char>)* '"' 




/*****   TEMPLATES   *****************************************/

<spaced template args>      ::= ' <' <template args'> '>' 

<spaced template def>       ::= ' <' <template def'> '>' 

<template args>             ::= '<' <template args'> '>' 
<template args'>            ::= [<expression> ( ',' <expression> )*]

<template def>              ::= '<' <template def'> '>' 
<template def'>             ::= (<identifier> |
                                 <const qualifier> <template def const name>) 
                                      ( ',' (<identifier> | 
                                             <const qualifier>
                                                 <template def const name>) )*

<template def const name>   ::= <scalar type or dotted name> <identifier>
                                    [ '=' <expression> ]




/*****   TYPES   ****************************************************/

<TYPE>                  ::= [<const qualifier>] <type>             
<TYPE'>                 ::= <const qualifier> <type>  |  <type'>

<type>                  ::= <type'>                         |
                            <templated type> [<dimensions>]
<type'>                 ::= <auto type>                     |
                            <enclosed types list>           |
                            <enum type>                     |
                            <NONE>                          |
                            <scalar type> 


<array type>            ::= 'array' <contained type> <dimensions>

<auto type>             ::= '?' [ 'in' <enclosed types list> ]

<const qualifier>       ::= 'const' 

<contained type>        ::= '<' (<TYPE> | <enclosed types list>) '>' 

<container type>        ::= <array type>  |  <file type>  |  <list type>  |
                            <map type>    |  <set type>

<dimensions>            ::= '[' [<integer number> | <dotted name>] ']'
                                ( '[' [<integer number> | <dotted name>] ']' )*

<enclosed types list>   ::= '(' <types list> ')' 

<scalar type or dotted name>    ::= <scalar type>  |  <dotted name>

<enum type>             ::= 'enum' 

<file type>             ::= 'file' [<contained type>]

<list type>             ::= 'list' [<contained type>]

<map type>              ::= 'map' [<contained type>]

<scalar type>           ::= 'bool'    | 'char'    | 'char16' |
                            'float32' | 'float64' |
                            'int8'    | 'int16'   | 'int32'  | 'int64'  |
                            'uint8'   | 'uint16'  | 'uint32' | 'uint64' |
                            'str'     | 'str16' 

<set type>              ::= 'set' [<contained type>]

<static qualifier>      ::= 'static' 

<templated type>        ::=  <dotted name> [<templated type spec>]
<templated type spec>   ::= '<' <types and exprs list> '>' 

<types and exprs list>  ::= (<expression> | 
                             <templated type>) 
                                 ( ',' (<expression> | <templated type>) )*

<types list>            ::= <TYPE> ( ',' <TYPE> )*

<volatile qualifier>    ::= 'volatile' 


/*=========================================================================*/
