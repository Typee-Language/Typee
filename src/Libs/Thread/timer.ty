/***
Copyright (c) 2019 Philippe Schmouker, schmouk (at) typee.ovh

Permission is hereby granted,  free of charge,  to any person obtaining a copy
of this software and associated documentation files (the "Software"),  to deal
in the Software without restriction, including  without  limitation the rights
to use,  copy,  modify,  merge,  publish,  distribute, sublicense, and/or sell
copies of the Software,  and  to  permit  persons  to  whom  the  Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY  KIND,  EXPRESS  OR
IMPLIED,  INCLUDING  BUT  NOT  LIMITED  TO  THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT  SHALL  THE
AUTHORS  OR  COPYRIGHT  HOLDERS  BE  LIABLE  FOR  ANY CLAIM,  DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  TORT OR OTHERWISE, ARISING FROM,
OUT  OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
***/

//=============================================================================
// Built-in library Thread
// Module timer.ty

//=============================================================================
from Thread.thread_exceptions import TimerStartException;

//=============================================================================
// targeted languages specifics
embed py {{
import threading
}}

//=============================================================================
class Timer
/**
Typee implementation of the timer concept.
Timers are inactive for specified periods and run their code between
those periods.
*/

embed py {{ : threading.Timer }}

{
 :public:

    //-------------------------------------------------------------------------
    Timer( const str name )
    /**
    Default constructor.
    */
    {
        me._name    = name;
        me._name16  = none;
        me._running = False;
    }

    //-------------------------------------------------------------------------
    Timer( const str16 name )
    /**
    Default constructor.
    */
    {
        me._name    = none;
        me._name16  = name;
        me._running = False;
    }

    //-------------------------------------------------------------------------
    none destroy()
    /**
    Destructor. Cancels/stops this timer.
    */
    {
      embed py {{
        super().cancel()
      }}
    }

    //-------------------------------------------------------------------------
    abstract none run( ... args );
    /**
    This is the definition of the code run qwith this timer.
    Has to be implemented in inheriting classes.
    */

    //-------------------------------------------------------------------------
    final none start( const float32 period, ... args )
    /**
    Starts the infinite running of this timer.  Internally  calls  
    method 'run()' with variable argument 'args'.
    Infinite running can be stopped by deleting the timer.
    Raises TimerStartException if starting again a running timer.
    Raises AssertException if period (unit: seconds) is negative.
    */
    {
        me.start( 0, period, args );
    }

    //-------------------------------------------------------------------------
    final none start( const uint64 n_times, const float32 period, ... args )
    /**
    Starts the running n_times of this timer.  Internally  calls  
    method 'run()' with variable argument 'args'. n_times set to
    0 means infinite running.
    Running can be stopped by deleting the timer.
    Raises TimerStartException if starting again a running timer.
    Raises AssertException if period (unit: seconds) is negative.
    */
    {
        assert period >= 0.0;
        if ( me._running )
            raise TimerStartException( me );

        me._count, me._nb = 0, n_times;
        me._running = true;
        
      embed py {{
        _args = ( arg for arg in args )
        super().__init__( period, self.run, _args )
      }}
    }

    //-------------------------------------------------------------------------
    str operator str ()
    {
        return me.name;
    }
    //-------------------------------------------------------------------------
    str16 operator str16 ()
    {
        return me.name16;
    }

 :protected:
    //-------------------------------------------------------------------------
    str     _name;
    str16   _name16;
    bool    _running;
    uint64  _count, _nb;
 
 :hidden: 
    //-------------------------------------------------------------------------
    final none _run( ... args )
    /**
    Runs the internal code for this timer.
    The internal code for timers is defined in method 'run()'.
    */
    {
        if ( me._nb == 0  or  me._count < me._nb )
        {
            me.run( args );
            ++ me._count;
        }
        else
            delete me;
    }
}

//===== end of module   Thread.timer.ty   =====//
